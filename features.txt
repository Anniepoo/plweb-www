# SWI-Prolog's features

SWI-Prolog is a versatile implementation of the Prolog language. Its
robust multi-threading, extended data types, unbounded arithmetic and
Unicode representation of text allow for natural representation of
documents (e.g., XML, JSON, RDF) and __exchange of data with other
programming paradigms__. Its comprehensive low-level interface to C is
the basis for high-level interfaces to C++, Java (bundled), C#, Python,
etc (externally available).

Prolog's __relational paradigm__ fits well with tabular data (RDBMS),
while __optimized support for recursive code__ fits well with tree and
graph shaped data (RDF). Prolog can naturally express simple rule sets
required to implement the _application logic_.

__Constraints__ and _coroutining_ attach rules to (changing) data.
Combined with backtracking, this can be used to solve many complicated
combinatorial problems using a simple declarative specification.
Classical examples are puzzles and planning problems.

SWI-Prolog is equipped with an extensive __web server__ (HTTP) framework
that can be used both for providing (REST) services and end-user
applications based on HTML5+CSS+JavaScript. Pengines (Prolog engines)
allow clients to run queries against a client-provided program on a
remote server using a generic API. Such programs can be executed in a
_sandbox_.

For (web) server support SWI-Prolog provides __scalable multi
threading__. We measured an 80 times speedup running on a 128 core power
pc system. This feature makes SWI-Prolog attractive for CPU intensive
server tasks where multiple clients require access to a large shared and
possibly dynamic dataset. Note that many other high-level languages such
as Python and Node.js only use a single core and switch between tasks
based on blocking I/O. This approach generally provides good resource
usage for I/O intensive services with a high number of connections but a
task blocking on a computation delays all other clients. As SWI-Prolog's
_global gargage collectors__ for atoms and removed dynamic clauses run
__fully asynchronous__ in a dedicated thread, its (soft) _real time_
behaviour is excellent.

Equipped with rich interfaces, Prolog is an attractive language for
application programming. Its __incremental compilation__ combined with
generally local and backtrackable data structures (undo) allows for
__patching the program without restarting__. SWI-Prolog allows for
reloading running code from another thread safely, provided the
signature of the running predicates is not changed. This implies it is
allowed to add, remove and modify clauses but it is _not_ allowed to
add, remove or reorder arguments. Still, this feature is valuable for
__hot-fixing servers__ or __inject diagniostic code__ to a server
without restarting.

SWI-Prolog offers a variety of __development environments__, most of
which may be combined at will. The native system provides an editor
written in Prolog that is a close clone of Emacs. It provides _semantic_
highlighting based on real time analysis of the code by the Prolog
system itself. Complementary tools include a graphical debugger,
profiler and cross-referencer. Alternatvely, there is a mode for
GNU-Emacs and, Eclipse plugin called
[PDT](https://sewiki.iai.uni-bonn.de/research/pdt/docs/start) and a VSC
[plugin](https://marketplace.visualstudio.com/items?itemName=arthurwang.vsc-prolog),
each of which may be combined with the native graphical tools. Finally,
SWISH provides a web-based environment based on the forementioned
_Pengines_ that can both be used to provide sandboxed access or full
access after authentication. SWISH offers editing multiple sources using
_semantic_ highlighting. SWISH can manage plugins for rendering Prolog
data using HTML5+CSS+JavaScript. This can be used to render data as
tables, graphs, charts, etc.

SWI-Prolog provides an add-on distribution and installation mechanism
called __packs__. A _pack_ is a directory with minimal organizational
conventions and a _control_ file that describes the origin, version,
dependencies and automatic upgrade support. Packs can be installed from
an archive, GIT repository or URL using pack_install/1. Packs are used
to share code in the community. The pack system has grown a couple of
eco systems for dealing with types, coroutining, etc.

Below is a list of what we consider key features of SWI-Prolog with
links to the relevant documentation.

## Engine

    * *fast* compilation. E.g., loads [WordNet
    3.0](https://wordnet.princeton.edu/wordnet/download/current-version/)
    in 14 seconds from the Prolog source or 0.4 seconds from _quick load
    file_ format (see qcompile/1).  The WordNet source counts 821,515
    lines.  System: Ubuntu 16.04 on Intel i7-3770, 32Gb memory.

    * *Robust* and *|free of memory leaks|*.  In use for several
    servers that run 24x7 (including this web service).

    * *Small*. The full development environment, including graphics,
    libraries and many interface packages, requires approx. 100MB
    hard disk. The kernel is about 1.4MB (Ubuntu 16.04 .so file)

    * *Scales* well for large applications. *No limits* on program size,
    atom length, term arity or integer values. No performance
    degradation on predicates with many (indexed) facts.

    * *|Just-In-Time|* indexing of both static and dynamic code on any
    argument greatly simplifies handling multi-moded relations with
    many clauses. As of version 7.5, __multi-argument JITI__ is
    supported. This creates an index for the combined value of two
    arguments if there is no selective single-argument index.  As of
    version 7.7 we also support indexing on the arguments of compound
    terms.  This feature notably improves the performance for handling
    _terminals_ in grammar rules (DCGs).

    * *|Unbounded integer|* and *rational* number arithmetic
    based on [[GMP library][<gmp:>]].

    * The goodies: *modules* (upward compatible to Quintus and SICStus),
    *|garbage-collection|* (transparent to C/C++-code, including *atom*
    and *clause* garbage collection), *|last-call|* optimisation,
    dynamic expansion of the runtime stacks, *|exception-handling|*
    (including C/C++ interface for both catching and throwing
    exceptions).

    * *|attributed variables|*, coroutining (freeze/2, when/2, dif/2),
    global variables, cyclic terms.

    * Flag-controlled handling of *|occurs-check|* (false/true/error)
    see current_prolog_flag/2. Efficient implementation of occurs
    checking that only verifies that _new bindings_ do not introduce
    cycles.

    * *UNICODE* character set handling internal. Ideal for web and
    international applications.

    * *|[[Multi-threading][</man/threads.html>]]|* support: run multiple
    pre-emptively scheduled prolog engines on the same database.

    * [*Engines*](</pldoc/man?section=engines>), also known as
    *interactors* provide _coroutines_ that can be used for state
    accumulation and massive concurrency for e.g., _swarm intelligence_
    and similations.

    * [*Delimited continuations*](</pldoc/man?section=delcont>) is a
    powerful building block for new control structures and realise
    __aspect programming__.

    * [Tabling (SLG resolution)](<pldoc/man?section=tabling>) provides
    a more robust resolution technique for solving queries over complex
    interrelated rules with guaranteed termination.

## Development tools

    * [[Source-level debugger][<gtrace.html>]] on all platforms that
    supports graphics through XPCE (Windows, Unix/Linux, MacOSX).

    * Execution *|profiler.txt|* (time and call statistics) for all
    major platforms (Windows, Linux, MacOSX).

    * *|[[Cross-Referencer][gxref.txt]]|*. gxref/0 provides a graphical
    front-end for the extensible Prolog cross-referencer (xref).

    * *|Literate programming|* support through
    *|[[PlDoc][</pldoc/package/pldoc.html>]]|*. Provides integrated view
    on manual and application documentation and producing LaTeX
    documentation for your application.

    * *|Unit testing|* support through
    *|[[PlUnit][</pldoc/package/plunit.html>]]|*.

    * [*SWISH*](https://swish.swi-prolog.org) provides a web-based
    platform for developing and running Prolog code in a collaborative
    environment.

## Compatibility

    * Comprehensive set of built-in predicates, covering *|Part 1 of the
    ISO standard|*, the de-facto *Edinburgh* Prolog standard and
    important parts of Quintus and SICStus Prolog. Fair
    compatibility to Ciao, YAP and GNU-Prolog.  Although the aim is to
    maintain compatibility wherever possible, SWI-Prolog deliberately
    deviates from the ISO standard to accomodate additional
    functionality and synchronise with modern languages.  Read
    more in [Extensions](<pldoc/man?section=extensions>) and
    [Directions](</Directions.html>)

## Constraing handling

    * Libraries for
    *|[[CHR][</man/chr.html>]]|* (Constraint Handling
    Rules), *|[[clp(FD)][</man/clpfd.html>]]|*,
    *|[[clp(R,Q)][</man/clpqr.html>]]|* and various others.

## Connectivity

    * SWI-Prolog provides extensive client and *server* libraries
    for *HTTP*.  The HTTP server framework deals with generating
    HTML, exchange of JSON or XML, authentication, sessions, and
    much more.  Both client and server supports HTTPS.

    * Flexible and fast interface to the *|C-|* and *|C++-language|*.
    The interface allows for calling both ways, handling of
    non-determinism both ways and *embedding* of the SWI-Prolog kernel
    in C/C++ projects.

    * Interfaces to high level languages such as
    Java using [JPL](</packages/jpl/>), Python and C# are available.

    * Database connectivity is provided by the
    *|[[ODBC][</pldoc/package/odbc.html>]]|* interface.

    * Low level network support includes _sockets_ (both TCP
    and UDP), *|[[SSL][</pldoc/package/ssl.html>]]|* and
    [TIPC](</pldoc/package/tipc.html>).

    * Fast and flexible libraries for *|[[parsing
    SGML/XML][</pldoc/package/sgml.html>]]|* (HTML),
    *|[[parsing][</pldoc/package/rdf2pl.html>]]|* *RDF*,
    *|[[store and query][</pldoc/package/semweb.html>]]|* the RDF
    _|triple model|_.


## Portability

    * *Portable* to many platforms, including almost all *|Unix/Linux|*
    platforms, *Windows*, *|MacOS X|* (using Xquartz for graphics)
    __WebAssembly (WASM)__, __Android Termux__ and many more. Both
    __32-bit__ and __64-bit__ hardware is supported. SWI-Prolog has been
    compiled and tested on many CPUs, e.g., x86, x64, SPARC, PowerPC,
    many ARM models. Sources are plain C99, configured automatically
    using CMake (as of version 7.7.20). Support for cross-compilation is
    steadily improving.

    * Machine-independent *|saved-states|* (save on one platform, run
    using the virtual machine of another platform).

    * Regular *|binary distributions|* for Windows (32/64 bits) and
    MacOS X (64 bits)) and PPAs for
    [Ubuntu](http://www.ubuntu.com) ([stable](https://launchpad.net/~swi-prolog/+archive/stable)
    and [development](https://launchpad.net/~swi-prolog/+archive/devel))

    * Regular distribution of the *full source* packages. The sources are
    also accessible through [[GIT][</git.html>]].

## Legal

    * SWI-Prolog is distributed under the _Simplified
    BSD license_, also known as the BSD-2 license. Some of the used
    libraries and extension packages have different license conditions.
    The licenses applicable to a running configuration can be examined
    by running license/0.  See license.txt for details.
